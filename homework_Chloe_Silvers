import numpy as np
np.random.seed(1350)

def problem1():
    # a) Create a 1D array of integers from 10 to 50 (inclusive) with step 5
    arr1 = np.arange(10, 51, 5)  
    # b) Create a 2D array of shape (3, 4) filled with zeros
    arr2 = np.zeros((3, 4))
    # c) Create a 3x3 identity matrix
    identity = np.eye(3)  
    # d) Create an array of 10 evenly spaced numbers between 0 and 5
    linspace_arr = np.linspace(0, 5, 10) 
    # e) Create a random array of shape (2, 5) with values between 0 and 1
    random_arr = np.random.rand(2, 5) 
    return arr1, arr2, identity, linspace_arr, random_arr


def problem2():
    "Perform array operations using broadcasting."
    arr_a = np.array([[1, 2, 3],
                      [4, 5, 6],
                      [7, 8, 9]])
    arr_b = np.array([10, 20, 30])

    # a) Add arr_b to each row of arr_a (broadcasting)
    result_add = arr_a + arr_b  
    # Explanation: lecture emphasized "broadcasting".
    # Shape (3,3) + (3,) automatically applies arr_b to each row.

    # b) Multiply each column of arr_a by the corresponding element in arr_b
    result_multiply = arr_a * arr_b  
    # Explanation: same broadcasting. Each column j is multiplied by arr_b[j].

    # c) Calculate the square of all elements in arr_a
    result_square = arr_a ** 2  
    # Explanation: vectorized power operator works elementwise (no loop needed).

    # d) Calculate the mean of each column in arr_a
    column_means = arr_a.mean(axis=0)  
    # Explanation: axis=0 means "down the rows", so we get column means.

    # e) Subtract the column means from each element in the respective column
    centered_arr = arr_a - column_means  
    # Explanation: broadcasting again – column_means shape (3,) is stretched
    # to match each row.

    return result_add, result_multiply, result_square, column_means, centered_arr


def problem3():
    "Demonstrate array indexing and slicing."
    arr = np.arange(1, 26).reshape(5, 5)

    # a) Extract the third row
    third_row = arr[2, :]  
    # Explanation: arr[row, :] → row 2 (third row). Colon means "all columns".

    # b) Extract the last column
    last_column = arr[:, -1]  
    # Explanation: arr[:, col] → all rows, last column (index -1).

    # c) Extract the 2x2 subarray from the center (rows 1-2, columns 1-2)
    center_subarray = arr[1:3, 1:3]  
    # Explanation: arr[row_start:row_end, col_start:col_end].
    # Here rows 1-2, cols 1-2 → 2x2 from middle.

    # d) Extract all elements greater than 15
    greater_than_15 = arr[arr > 15]  
    # Explanation: boolean mask indexing, very common in lecture.

    # e) Replace all even numbers with -1 (create a copy first)
    arr_copy = arr.copy()
    arr_copy[arr_copy % 2 == 0] = -1  
    # Explanation: arr % 2 == 0 creates True for even numbers.
    # Then assignment replaces them with -1.

    return third_row, last_column, center_subarray, greater_than_15, arr_copy


def problem4():
    "Perform statistical analysis on student scores."
    scores = np.array([[85, 90, 78, 92],
                       [79, 85, 88, 91],
                       [92, 88, 95, 89],
                       [75, 72, 80, 78],
                       [88, 91, 87, 94]])

    # a) Calculate the average score for each student (across all tests)
    student_averages = scores.mean(axis=1)  
    # Explanation: axis=1 means average across columns → per row (student).

    # b) Calculate the average score for each test (across all students)
    test_averages = scores.mean(axis=0)  
    # Explanation: axis=0 means average across rows → per column (test).

    # c) Find the highest score for each student
    student_max_scores = scores.max(axis=1)  
    # Explanation: max row-wise gives highest test score per student.

    # d) Find the standard deviation of scores for each test
    test_std = scores.std(axis=0)  
    # Explanation: std along axis=0 gives spread of each column (test).

    # e) Identify which students have an average score above 85
    high_performers = student_averages > 85  
    # Explanation: boolean mask, True if avg > 85.

    return student_averages, test_averages, student_max_scores, test_std, high_performers


def problem5():
    "Compare performance between NumPy arrays and Python lists."
    import time
    size = 100000
    python_list = list(range(size))
    numpy_array = np.arange(size)

    # Python list approach
    start_time = time.perf_counter()
    list_result = [x * x for x in python_list]  
    # Explanation: pure Python loop in list comprehension.
    list_time = time.perf_counter() - start_time

    # NumPy array approach
    start_time = time.perf_counter()
    array_result = numpy_array ** 2  
    # Explanation: vectorized operation – runs in C under the hood.
    numpy_time = time.perf_counter() - start_time

    speedup = list_time / numpy_time
    return {
        'list_time': list_time,
        'numpy_time': numpy_time,
        'speedup': speedup,
        'conclusion': f"NumPy is {speedup:.1f}x faster than Python lists for this operation"
    }



if __name__ == "__main__":
    print("Problem 1 Results:")
    print(problem1())
    print("\nProblem 2 Results:")
    print(problem2())
    print("\nProblem 3 Results:")
    print(problem3())
    print("\nProblem 4 Results:")
    print(problem4())
    print("\nProblem 5 Results:")
    print(problem5())
    
